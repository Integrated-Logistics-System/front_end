'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { io, Socket } from 'socket.io-client';

interface ChatMessage {
  id: string;
  content: string;
  isUser: boolean;
  timestamp: string;
}

interface UseWebSocketChatProps {
  userId?: string;
  token?: string;
}

export function useWebSocketChat({ userId, token }: UseWebSocketChatProps) {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [authenticatedUser, setAuthenticatedUser] = useState<any>(null);
  const [isTyping, setIsTyping] = useState(false);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [connectionError, setConnectionError] = useState<string | null>(null);
  const [isLoadingHistory, setIsLoadingHistory] = useState(false);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();
  const messageBufferRef = useRef<string>('');
  const historyRequestedRef = useRef<boolean>(false); // üî• Ï§ëÎ≥µ ÏöîÏ≤≠ Î∞©ÏßÄ
  const historyLoadedRef = useRef<boolean>(false); // üî• ÌûàÏä§ÌÜ†Î¶¨ Î°úÎî© ÏôÑÎ£å Ïó¨Î∂Ä

  // WebSocket Ïó∞Í≤∞
  const connect = useCallback(() => {
    console.log('üîç useWebSocketChat Debug:', { userId, token });
    
    if (!token) {
      console.warn('No token provided for WebSocket connection');
      setConnectionError('No authentication token');
      return;
    }

    if (socket?.connected) {
      console.log('‚ÑπÔ∏è Already connected to WebSocket');
      return;
    }

    try {
      console.log('üîó Connecting to WebSocket...');
      
      // üî• ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      historyRequestedRef.current = false;
      historyLoadedRef.current = false; // üî• ÌûàÏä§ÌÜ†Î¶¨ Î°úÎî© ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      setIsLoadingHistory(false);

      const newSocket = io(process.env.NEXT_PUBLIC_WS_URL || 'http://localhost:8083', {
        auth: {
          token: token
        },
        transports: ['websocket', 'polling'],
        timeout: 10000,
        reconnection: true,
        reconnectionAttempts: 5,
        reconnectionDelay: 1000,
      });

      // Ïó∞Í≤∞ ÏÑ±Í≥µ
      newSocket.on('connect', () => {
        console.log('‚úÖ WebSocket connected');
        setIsConnected(true);
        setConnectionError(null);
        
        // üî• Ïù∏Ï¶ù ÏôÑÎ£å ÌõÑÏóê join-personal-chatÏùÑ Î≥¥ÎÇ¥ÎèÑÎ°ù Î≥ÄÍ≤Ω
        console.log('‚è≥ Waiting for authentication confirmation...');
      });

      // Ïó∞Í≤∞ ÌôïÏù∏
      newSocket.on('connected', (data) => {
        console.log('üì° Connection confirmed:', data);
        
        // Ïù∏Ï¶ù ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        if (data.user && data.user.id) {
          setIsAuthenticated(true);
          setAuthenticatedUser(data.user);
          setConnectionError(null);
          console.log('‚úÖ Ïù∏Ï¶ù ÏÑ±Í≥µ:', data.user.email);
          
          // üî• Ïù∏Ï¶ù ÏÑ±Í≥µ ÌõÑ join-personal-chat Ï†ÑÏÜ° (Ìïú Î≤àÎßå)
          if (!historyRequestedRef.current && !historyLoadedRef.current) {
            console.log('üì• Now joining personal chat after authentication...');
            newSocket.emit('join-personal-chat');
            
            console.log('üîÑ Starting chat history loading...');
            setIsLoadingHistory(true);
            historyRequestedRef.current = true;
            
            // üî• Í∞ïÌôîÎêú ÏïàÏ†ÑÏû•Ïπò: 3Ï¥à ÌõÑÏóêÎèÑ ÌûàÏä§ÌÜ†Î¶¨Í∞Ä Ïïà Ïò§Î©¥ Îπà ÏÉÅÌÉúÎ°ú ÏÑ§Ï†ï
            setTimeout(() => {
              if (isLoadingHistory && !historyLoadedRef.current) {
                console.warn('‚è∞ Chat history loading timeout - setting empty messages for first time chat');
                setIsLoadingHistory(false);
                setMessages([]);
                historyRequestedRef.current = false;
                historyLoadedRef.current = true; // üî• ÌÉÄÏûÑÏïÑÏõÉÎèÑ Î°úÎî© ÏôÑÎ£åÎ°ú Ï≤òÎ¶¨
              }
            }, 3000);
          } else {
            console.log('üö´ History already requested or loaded - skipping');
          }
        } else {
          setIsAuthenticated(false);
          setAuthenticatedUser(null);
          setConnectionError('Ïù∏Ï¶ùÎêòÏßÄ ÏïäÏùÄ Ïó∞Í≤∞');
          console.warn('‚ö†Ô∏è ÏùµÎ™Ö Ïó∞Í≤∞: Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§');
          setIsLoadingHistory(false);
        }
      });

      // üî• Ï±ÑÌåÖ ÌûàÏä§ÌÜ†Î¶¨ ÏàòÏã†
      newSocket.on('chat-history', (data) => {
        console.log('üìú Chat history received:', data);
        
        // üî• Î°úÎî© ÏÉÅÌÉú Ï¶âÏãú Ìï¥Ï†ú Î∞è Î°úÎî© ÏôÑÎ£å ÌëúÏãú
        setIsLoadingHistory(false);
        historyRequestedRef.current = false;
        historyLoadedRef.current = true; // üî• ÌûàÏä§ÌÜ†Î¶¨ Î°úÎî© ÏôÑÎ£å
        
        const historyMessages = data.messages || data || [];
        
        if (!Array.isArray(historyMessages)) {
          console.warn('‚ö†Ô∏è Chat history messages is not an array:', typeof historyMessages, historyMessages);
          console.log('üîÑ Setting empty messages for first time chat');
          setMessages([]);
          return;
        }
        
        // üî• Îπà Î∞∞Ïó¥Ïù¥Ïñ¥ÎèÑ Ï†ïÏÉÅ Ï≤òÎ¶¨
        if (historyMessages.length === 0) {
          console.log('üì≠ No previous chat history - starting fresh conversation');
          setMessages([]);
          return;
        }
        
        const formattedMessages: ChatMessage[] = historyMessages
          .map((item: any, index: number) => {
            if (!item || typeof item !== 'object') {
              console.warn('‚ö†Ô∏è Invalid history item:', item);
              return null;
            }
            
            return {
              id: `history-${item.timestamp || index}`,
              content: item.content || '',
              isUser: item.role === 'user',
              timestamp: item.timestamp ? new Date(item.timestamp).toISOString() : new Date().toISOString(),
            };
          })
          .filter((msg): msg is ChatMessage => msg !== null);
        
        console.log(`‚úÖ Loaded ${formattedMessages.length} messages from chat history`);
        
        const sortedMessages = formattedMessages.sort((a, b) => 
          new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
        );
        
        setMessages(sortedMessages);
        
        if (data.source) {
          console.log(`üìÇ Memory source: ${data.source} (${data.memoryType || 'unknown'})`);
        }
      });

      // üî• Ï±ÑÌåÖ Í∏∞Î°ù ÌÅ¥Î¶¨Ïñ¥ ÌôïÏù∏
      newSocket.on('chat-history-cleared', (data) => {
        console.log('üóëÔ∏è Chat history cleared:', data);
        if (data.success) {
          setMessages([]);
          // üî• ÌÅ¥Î¶¨Ïñ¥ ÌõÑÏóêÎäî Îã§Ïãú Î°úÎî© Í∞ÄÎä•ÌïòÎèÑÎ°ù ÏÑ§Ï†ï
          historyLoadedRef.current = false;
          historyRequestedRef.current = false;
          console.log('‚úÖ Local chat history cleared and ready for new conversation');
        }
      });

      // Ïä§Ìä∏Î¶¨Î∞ç Î©îÏãúÏßÄ ÏàòÏã†
      newSocket.on('chat-stream', (data) => {
        if (data.type === 'start') {
          console.log('üöÄ Streaming started');
          messageBufferRef.current = '';
          setIsTyping(true);
        } else if (data.type === 'content') {
          messageBufferRef.current += data.data;
          
          setMessages(prev => {
            const lastMessage = prev[prev.length - 1];
            if (lastMessage && !lastMessage.isUser) {
              return [
                ...prev.slice(0, -1),
                {
                  ...lastMessage,
                  content: messageBufferRef.current,
                }
              ];
            } else {
              return [
                ...prev,
                {
                  id: `ai-${Date.now()}`,
                  content: messageBufferRef.current,
                  isUser: false,
                  timestamp: new Date().toISOString(),
                }
              ];
            }
          });
        } else if (data.type === 'end') {
          console.log('‚úÖ Streaming completed');
          setIsTyping(false);
        }
      });

      // ÌÉÄÏù¥Ìïë ÏÉÅÌÉú
      newSocket.on('chat-status', (data) => {
        if (data.type === 'typing') {
          setIsTyping(data.isTyping);
        }
      });

      // Î©îÏãúÏßÄ ÏôÑÎ£å
      newSocket.on('message-complete', (data) => {
        console.log('üì® Message completed');
        setIsTyping(false);
      });

      // üî• ÏóêÎü¨ Ï≤òÎ¶¨ Í∞úÏÑ†
      newSocket.on('chat-error', (error) => {
        console.error('‚ùå Chat error:', error);
        setConnectionError(error.message);
        setIsTyping(false);
        
        // üî• ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥ÎèÑ Î°úÎî© ÏÉÅÌÉúÎäî Ìï¥Ï†úÌïòÍ≥† Îπà Î©îÏãúÏßÄÎ°ú ÏÑ§Ï†ï
        if (isLoadingHistory) {
          console.log('üîß Chat error occurred - setting empty messages for first time chat');
          setIsLoadingHistory(false);
          historyRequestedRef.current = false;
          historyLoadedRef.current = true; // üî• ÏóêÎü¨ÏóêÎèÑ Î°úÎî© ÏôÑÎ£åÎ°ú Ï≤òÎ¶¨
          setMessages([]);
        }
      });

      // Ïó∞Í≤∞ Ìï¥Ï†ú
      newSocket.on('disconnect', (reason) => {
        console.warn('üîå WebSocket disconnected:', reason);
        setIsConnected(false);
        setIsAuthenticated(false);
        setAuthenticatedUser(null);
        setIsLoadingHistory(false);
        historyRequestedRef.current = false;
        historyLoadedRef.current = false; // üî• Îã§Ïãú Ïó∞Í≤∞ Ïãú ÌûàÏä§ÌÜ†Î¶¨ Î°úÎî© Í∞ÄÎä•
        
        if (reason === 'io server disconnect') {
          reconnectTimeoutRef.current = setTimeout(() => {
            console.log('üîÑ Attempting to reconnect...');
            newSocket.connect();
          }, 2000);
        }
      });

      // Ïó∞Í≤∞ ÏóêÎü¨
      newSocket.on('connect_error', (error) => {
        console.error('‚ùå Connection error:', error);
        setConnectionError(`Connection failed: ${error.message}`);
        setIsConnected(false);
        setIsLoadingHistory(false);
        historyRequestedRef.current = false;
        historyLoadedRef.current = false; // üî• Ïó∞Í≤∞ ÏóêÎü¨ Ïãú Î¶¨ÏÖã
      });

      setSocket(newSocket);

    } catch (error) {
      console.error('‚ùå Socket creation error:', error);
      setConnectionError('Failed to create socket connection');
      setIsLoadingHistory(false);
      historyRequestedRef.current = false;
      historyLoadedRef.current = false; // üî• ÏÉùÏÑ± ÏóêÎü¨ Ïãú Î¶¨ÏÖã
    }
  }, [token, isLoadingHistory]);

  // üî• ÏàòÎèôÏúºÎ°ú ÎåÄÌôî Í∏∞Î°ù ÏöîÏ≤≠ÌïòÎäî Ìï®Ïàò Í∞úÏÑ†
  const requestChatHistory = useCallback(() => {
    if (!socket || !isConnected || !isAuthenticated) {
      console.warn('Cannot request chat history: not ready');
      return;
    }
    
    if (historyRequestedRef.current || historyLoadedRef.current) {
      console.log('üìã Chat history already requested or loaded');
      return;
    }
    
    console.log('üìã Manually requesting chat history...');
    setIsLoadingHistory(true);
    historyRequestedRef.current = true;
    
    socket.emit('join-personal-chat');
    
    setTimeout(() => {
      if (isLoadingHistory && !historyLoadedRef.current) {
        console.warn('‚è∞ Manual chat history loading timeout');
        setIsLoadingHistory(false);
        historyRequestedRef.current = false;
        historyLoadedRef.current = true;
        setMessages([]);
      }
    }, 3000);
  }, [socket, isConnected, isAuthenticated, isLoadingHistory]);

  // Î©îÏãúÏßÄ Ï†ÑÏÜ°
  const sendMessage = useCallback((message: string) => {
    if (!socket || !isConnected || !message.trim()) {
      console.warn('Cannot send message: socket not ready or empty message');
      return;
    }

    console.log('üì§ Sending message:', message);

    const userMessage: ChatMessage = {
      id: `user-${Date.now()}`,
      content: message,
      isUser: true,
      timestamp: new Date().toISOString(),
    };

    setMessages(prev => [...prev, userMessage]);
    socket.emit('send-personal-message', { message });
  }, [socket, isConnected]);

  // Ï±ÑÌåÖ ÌûàÏä§ÌÜ†Î¶¨ ÏßÄÏö∞Í∏∞
  const clearHistory = useCallback(() => {
    if (!socket || !isConnected) return;

    console.log('üóëÔ∏è Clearing chat history...');
    socket.emit('clear-chat-history');
  }, [socket, isConnected]);

  // Ïó∞Í≤∞ Ìï¥Ï†ú
  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }

    if (socket) {
      console.log('üîå Disconnecting WebSocket...');
      socket.emit('leave-personal-chat');
      socket.disconnect();
      setSocket(null);
    }

    setIsConnected(false);
    setIsTyping(false);
    setConnectionError(null);
    setIsLoadingHistory(false);
    historyRequestedRef.current = false;
    historyLoadedRef.current = false; // üî• Ïó∞Í≤∞ Ìï¥Ï†ú Ïãú Î¶¨ÏÖã
  }, [socket]);

  // üî• Ïù∏Ï¶ù ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïãú ÎåÄÌôî Í∏∞Î°ù ÏöîÏ≤≠ (Îã®ÏàúÌôî)
  useEffect(() => {
    // Ïù∏Ï¶ù ÏÑ±Í≥µ ÌõÑ ÏµúÏ¥à 1ÌöåÎßå Ïã§Ìñâ
    if (isAuthenticated && isConnected && !historyRequestedRef.current && !historyLoadedRef.current) {
      console.log('üîÑ Auth state changed - ready to request chat history');
      // join-personal-chatÏùÄ connected Ïù¥Î≤§Ìä∏ÏóêÏÑú Ïù¥ÎØ∏ Ï≤òÎ¶¨
    }
  }, [isAuthenticated, isConnected]); // messages.length Ï†úÍ±∞

  // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏/Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Ïó∞Í≤∞ Í¥ÄÎ¶¨
  useEffect(() => {
    if (userId && token) {
      // üî• Ïó∞Í≤∞ Ïãú ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      historyLoadedRef.current = false;
      connect();
    }

    return () => {
      disconnect();
    };
  }, [userId, token]); // connect, disconnect Ï†úÍ±∞

  return {
    // ÏÉÅÌÉú
    isConnected,
    isAuthenticated,
    authenticatedUser,
    isTyping,
    messages,
    connectionError,
    isLoadingHistory,
    
    // Ïï°ÏÖò
    sendMessage,
    clearHistory,
    disconnect,
    reconnect: connect,
    requestChatHistory, // üî• ÏàòÎèô ÏöîÏ≤≠ Ìï®Ïàò Ï∂îÍ∞Ä
  };
}